import typing, clr, abc
from System import Array_1, MulticastDelegate, IAsyncResult, AsyncCallback, IDisposable
from System.Reflection import MethodInfo

class Analog(ContinuousSensor):
    @property
    def A0(self) -> AnalogInput: ...
    @property
    def A1(self) -> AnalogInput: ...
    @property
    def A2(self) -> AnalogInput: ...
    @property
    def A3(self) -> AnalogInput: ...
    @property
    def A4(self) -> AnalogInput: ...
    @property
    def A5(self) -> AnalogInput: ...
    @property
    def A6(self) -> AnalogInput: ...
    @property
    def A7(self) -> AnalogInput: ...
    @property
    def IsEnabled(self) -> bool: ...
    @property
    def IsReady(self) -> bool: ...
    def DisableInputsA(self, inputPins: Array_1[int]) -> None: ...
    def EnableInputsA(self, inputPins: Array_1[int]) -> None: ...
    def SetSampleRate(self, sampleRateHz: int) -> None: ...
    def UseConverter(self, converter: AnalogConverter, input: Array_1[AnalogInput]) -> None: ...


class AnalogConverter(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, inputValue: float, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> float: ...
    def Invoke(self, inputValue: float) -> float: ...


class AnalogInput:
    @property
    def Value(self) -> float: ...
    @Value.setter
    def Value(self, value: float) -> float: ...
    # Operator not supported op_Implicit(a: AnalogInput)
    def ToString(self) -> str: ...


class Config:
    pass


class ConnectionState:
    @property
    def IsClosing(self) -> bool: ...
    @property
    def IsConnected(self) -> bool: ...


class ContinuousSensor(abc.ABC):
    @property
    def IsEnabled(self) -> bool: ...
    @property
    def IsReady(self) -> bool: ...
    def Disable(self) -> None: ...
    def Enable(self) -> None: ...


class Digital:
    @property
    def IN0(self) -> DigitalInput: ...
    @property
    def IN1(self) -> DigitalInput: ...
    @property
    def IN2(self) -> DigitalInput: ...
    @property
    def IN3(self) -> DigitalInput: ...
    @property
    def IN4(self) -> DigitalInput: ...
    @property
    def InputCount(self) -> int: ...
    def ClearInputEvents(self, timeoutMs: int = ...) -> None: ...
    def DisableInputs(self, inputPins: Array_1[int]) -> None: ...
    def EnableInputs(self, inputPins: Array_1[int]) -> None: ...
    def GetInputEvent(self) -> int: ...
    def GetIRCommand(self) -> IrCommand: ...
    def InvertInputs(self, inputPins: Array_1[int]) -> None: ...
    def ResetInputsState(self, inputPins: Array_1[int]) -> None: ...
    def ToString(self) -> str: ...
    def UseIrCommandConverter(self, converter: IrCommandConverter) -> None: ...


class DigitalInput:
    @property
    def Value(self) -> bool: ...
    # Operator not supported op_Implicit(d: DigitalInput)
    def ToString(self) -> str: ...


class DisplayLcd:
    def Clear(self) -> None: ...
    def PrintAt(self, col: int, row: int, text: str) -> None: ...
    def Sleep(self) -> None: ...
    def WakeUp(self) -> None: ...


class DisplayLed:
    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, value: float) -> None:...
        # Method Write(value : Single) was skipped since it collides with above method
        # Method Write(value : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, text: str) -> None:...



class Input(abc.ABC):
    BUTTON_1_PRESSED : int
    BUTTON_1_RELEASED : int
    BUTTON_1_SUSTAIN_RELEASED : int
    BUTTON_1_SUSTAINED : int
    BUTTON_2_PRESSED : int
    BUTTON_2_RELEASED : int
    BUTTON_2_SUSTAIN_RELEASED : int
    BUTTON_2_SUSTAINED : int
    BUTTON_3_PRESSED : int
    BUTTON_3_RELEASED : int
    BUTTON_3_SUSTAIN_RELEASED : int
    BUTTON_3_SUSTAINED : int
    IN0_TRIGGERED : int
    IN1_TRIGGERED : int
    IN2_TRIGGERED : int
    IN3_TRIGGERED : int
    IN4_TRIGGERED : int
    None : int


class IrCommand:
    @property
    def ButtonPressed(self) -> bool: ...
    @ButtonPressed.setter
    def ButtonPressed(self, value: bool) -> bool: ...
    @property
    def ButtonReleased(self) -> bool: ...
    @ButtonReleased.setter
    def ButtonReleased(self, value: bool) -> bool: ...
    @property
    def Code(self) -> int: ...
    @Code.setter
    def Code(self, value: int) -> int: ...
    @property
    def Name(self) -> str: ...
    @property
    def Received(self) -> bool: ...
    # Skipped Deconstruct due to it being static, abstract and generic.

    Deconstruct : Deconstruct_MethodGroup
    class Deconstruct_MethodGroup:
        @typing.overload
        def __call__(self, code: clr.Reference[int], buttonPressed: clr.Reference[bool], buttonReleased: clr.Reference[bool]) -> None:...
        @typing.overload
        def __call__(self, code: clr.Reference[int], name: clr.Reference[str], buttonPressed: clr.Reference[bool], buttonReleased: clr.Reference[bool]) -> None:...



class IrCommandConverter(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, irCode: int, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> str: ...
    def Invoke(self, irCode: int) -> str: ...


class Motor:
    @property
    def DurationLapsed(self) -> bool: ...
    def SetAcceleration(self, timeToMaxSpeed: float) -> None: ...
    def StopAccelerating(self) -> None: ...
    # Skipped Drive due to it being static, abstract and generic.

    Drive : Drive_MethodGroup
    class Drive_MethodGroup:
        def __call__(self, speedPercent: float) -> None:...
        # Method Drive(speedPercent : Int32) was skipped since it collides with above method

    # Skipped DriveForDuration due to it being static, abstract and generic.

    DriveForDuration : DriveForDuration_MethodGroup
    class DriveForDuration_MethodGroup:
        def __call__(self, speedPercent: float, duration: float) -> None:...
        # Method DriveForDuration(speedPercent : Int32, duration : Single) was skipped since it collides with above method

    # Skipped DriveNoAccel due to it being static, abstract and generic.

    DriveNoAccel : DriveNoAccel_MethodGroup
    class DriveNoAccel_MethodGroup:
        def __call__(self, speedPercent: float) -> None:...
        # Method DriveNoAccel(speedPercent : Int32) was skipped since it collides with above method



class MotorConfig:
    def SetSpeedLimits(self, maxReverseSpeed: int, maxForwardSpeed: int, motor: Motor) -> None: ...
    def SetSpeedMultiplier(self, speedMultiplier: float, motor: Motor) -> None: ...


class RobotIO(IDisposable):
    @typing.overload
    def __init__(self, port: str) -> None: ...
    @typing.overload
    def __init__(self, port: str, baud: int, dtrEnable: bool) -> None: ...
    @property
    def Analog(self) -> Analog: ...
    @property
    def ConnectionState(self) -> ConnectionState: ...
    @property
    def Digital(self) -> Digital: ...
    @property
    def Display(self) -> DisplayLcd: ...
    @property
    def LedDisplay(self) -> DisplayLed: ...
    @property
    def Motor1(self) -> Motor: ...
    @property
    def Motor2(self) -> Motor: ...
    @property
    def MotorConfig(self) -> MotorConfig: ...
    @property
    def RobotId(self) -> str: ...
    @RobotId.setter
    def RobotId(self, value: str) -> str: ...
    @property
    def Servo1(self) -> Servo: ...
    @property
    def Servo2(self) -> Servo: ...
    @property
    def Servo3(self) -> Servo: ...
    @property
    def Servo4(self) -> Servo: ...
    @property
    def ServoConfig(self) -> ServoConfig: ...
    @property
    def Sonar(self) -> Sonar: ...
    @property
    def Switch1(self) -> Switch: ...
    @property
    def Switch2(self) -> Switch: ...
    @property
    def Switch3(self) -> Switch: ...
    @property
    def Switch4(self) -> Switch: ...
    @property
    def Trigger(self) -> Trigger: ...
    def Close(self) -> None: ...
    def Connect(self) -> None: ...
    def Dispose(self) -> None: ...
    def NotifyClosing(self) -> None: ...
    # Skipped WaitUntilSensorsReady due to it being static, abstract and generic.

    WaitUntilSensorsReady : WaitUntilSensorsReady_MethodGroup
    class WaitUntilSensorsReady_MethodGroup:
        @typing.overload
        def __call__(self, sensors: Array_1[ContinuousSensor]) -> bool:...
        @typing.overload
        def __call__(self, timeoutMs: int, sensors: Array_1[ContinuousSensor]) -> bool:...



class Servo:
    @property
    def Position(self) -> float: ...
    @property
    def Range(self) -> ServoRange: ...
    def SetPosition(self, angle: float) -> None: ...
    def SetSpeed(self, speed: int) -> None: ...
    def Stop(self) -> None: ...


class ServoConfig:
    def SetAngleLimits(self, angleLowerLimit: int, angleUpperLimit: int, servo: Servo) -> None: ...
    def SetSpeedLimit(self, maxSpeed: int, servo: Array_1[Servo]) -> None: ...
    def SetType(self, maxAngle: int, minPulseWidth: int, maxPulseWidth: int, servo: Array_1[Servo]) -> None: ...


class ServoRange:
    @property
    def LowerLimit(self) -> int: ...
    @LowerLimit.setter
    def LowerLimit(self, value: int) -> int: ...
    @property
    def MaxAngle(self) -> int: ...
    @MaxAngle.setter
    def MaxAngle(self, value: int) -> int: ...
    @property
    def UpperLimit(self) -> int: ...
    @UpperLimit.setter
    def UpperLimit(self, value: int) -> int: ...


class Sonar:
    @property
    def DistanceAcquired(self) -> bool: ...
    def Clear(self) -> None: ...
    def GetDistance(self) -> int: ...
    def Ping(self) -> None: ...


class Switch:
    @property
    def DurationLapsed(self) -> bool: ...
    @property
    def IsOn(self) -> bool: ...
    @IsOn.setter
    def IsOn(self, value: bool) -> bool: ...
    def Off(self) -> None: ...
    def On(self) -> None: ...
    def OnForDuration(self, duration: float) -> None: ...


class Trigger:
    @property
    def IsActive(self) -> bool: ...
    def Off(self) -> None: ...
    def On(self) -> None: ...
    def Repeat(self, onPeriod: int, offPeriod: int) -> None: ...
    def RunPattern(self, onPeriod: int, offPeriod: int, cycles: int, loopCycles: int = ..., loopDelayPeriod: int = ...) -> None: ...
    # Skipped Pulse due to it being static, abstract and generic.

    Pulse : Pulse_MethodGroup
    class Pulse_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, onPeriod: int) -> None:...

    # Skipped SetOffPeriod due to it being static, abstract and generic.

    SetOffPeriod : SetOffPeriod_MethodGroup
    class SetOffPeriod_MethodGroup:
        def __call__(self, offPeriod: float) -> None:...
        # Method SetOffPeriod(offPeriod : Int32) was skipped since it collides with above method


